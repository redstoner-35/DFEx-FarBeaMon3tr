C51 COMPILER V9.60.0.0   SELFTEST                                                          05/15/2025 17:22:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SELFTEST
OBJECT MODULE PLACED IN .\Objects\SelfTest.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Logic\SelfTest.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODDP2 INCDIR(.\StdDriver
                    -\inc;.\Hardware;.\include\Hardware;.\include\Logic;.\include\Middleware;.\include\System) DEFINE(EnableStdGPIO) DEBUG PR
                    -INT(.\Listings\SelfTest.lst) TABS(2) OBJECT(.\Objects\SelfTest.obj)

line level    source

   1          #include "LEDMgmt.h"
   2          #include "delay.h"
   3          #include "ADCCfg.h"
   4          #include "BattDisplay.h"
   5          #include "ModeControl.h"
   6          #include "SelfTest.h"
   7          #include "OutputChannel.h"
   8          
   9          //内部变量
  10          static xdata int ErrDisplayIndex; //错误显示计时
  11          static xdata char ShortDetectTIM=0; //短路监测计时器
  12          static xdata char ShortBlankTIM; //短路blank定时器
  13          static code FaultCodeDef NonCriticalFault[]={ //非致命的错误代码
  14            Fault_DCDCOpen,
  15            Fault_DCDCShort, //开路和短路可能是误报，允许消除
  16            Fault_InputOVP
  17            };
  18            
  19          //外部全局参考
  20          xdata FaultCodeDef ErrCode; //错误代码  
  21          
  22          //查询错误是否致命
  23          bit IsErrorFatal(void)  
  24            {
  25   1        char i;
  26   1        for(i=0;i<sizeof(NonCriticalFault);i++)
  27   1          if(NonCriticalFault[i]==ErrCode)return 0;
  28   1        //寻找了目前已有的错误码发现是致命问题
  29   1        return 1;
  30   1        }
  31          
  32          //报告错误
  33          void ReportError(FaultCodeDef Code)
  34            {
  35   1        ErrCode=Code;
  36   1        if(CurrentMode->ModeIdx==Mode_Fault)return;
  37   1        SwitchToGear(Mode_Fault);  //指示故障发生
  38   1        }
  39          
  40          //消除错误
  41          void ClearError(void)
  42            {
  43   1        ErrCode=Fault_None;
  44   1        SwitchToGear(Mode_OFF);
  45   1        }
  46          
  47          //错误ID显示计时函数  
  48          void DisplayErrorTIMHandler(void) 
  49            {
  50   1        //没有错误发生，复位计时器
  51   1        if(ErrCode==Fault_None)ErrDisplayIndex=0;
  52   1        else //发生错误，开始计时
  53   1          {
C51 COMPILER V9.60.0.0   SELFTEST                                                          05/15/2025 17:22:34 PAGE 2   

  54   2          ErrDisplayIndex++;
  55   2          if(ErrDisplayIndex>=(5+(6*(int)ErrCode)+10))ErrDisplayIndex=0; //上限到了，开始翻转
  56   2          }
  57   1        }
  58          
  59          //出现错误时显示DCDC的错误ID
  60          void DisplayErrorIDHandler(void)
  61            {
  62   1        int buf;
  63   1        //先导提示红黄绿交替闪
  64   1        if(ErrDisplayIndex<5)
  65   1          {
  66   2          if(ErrDisplayIndex<3)LEDMode=(LEDStateDef)(ErrDisplayIndex+1);  
  67   2          else LEDMode=LED_OFF;
  68   2          }
  69   1        //闪烁指定次数显示Err ID
  70   1        else if(ErrDisplayIndex<(5+(6*(int)ErrCode)))
  71   1          {
  72   2          buf=(ErrDisplayIndex-5)/3; 
  73   2          if(!(buf%2))LEDMode=LED_Red;
  74   2          else LEDMode=LED_OFF;  //按照错误ID闪烁指定次数
  75   2          }
  76   1        else LEDMode=LED_OFF; //LED熄灭
  77   1        }
  78          //内部函数，故障计数器
  79          static char ErrTIMCounter(char buf,char Count)
  80            {
  81   1        //累加计数器
  82   1        return buf<8?buf+Count:8;
  83   1        }
  84          
  85          //输出故障检测
  86          void OutputFaultDetect(void)
  87            {
  88   1        char buf,OErrID;
  89   1        if(!GetIfOutputEnabled())ShortBlankTIM=0; //DCDC关闭
  90   1        else if(ShortBlankTIM<FaultBlankingInterval)ShortBlankTIM++; //时间未到不允许监测
  91   1        else  //开始检测
  92   1          {   
  93   2          buf=ShortDetectTIM&0x0F; //取出定时器值         
  94   2          //输入过压保护
  95   2          if(Data.BatteryVoltage>4.4)ReportError(Fault_InputOVP); 
  96   2          //短路检测  
  97   2          if(Data.OutputVoltage<14.6&&Data.FBInjectVolt>4.8) //输出短路
  98   2            {
  99   3            buf=ErrTIMCounter(buf,2); //计时器累计
 100   3            OErrID=0;
 101   3            }
 102   2          //输出开路检测
 103   2          else if(Data.FBInjectVolt<0.5&&Data.OutputVoltage>22.5) 
 104   2            {
 105   3            buf=ErrTIMCounter(buf,1); //计时器累计
 106   3            OErrID=1;
 107   3            }
 108   2          else buf=buf>0?buf-1:0; //没有发生错误，清除计数器
 109   2          //进行定时器数值的回写
 110   2          ShortDetectTIM=buf|(OErrID<<4);
 111   2          //状态检测
 112   2          if(buf<8)return; //没有故障,跳过执行
 113   2          switch((ShortDetectTIM>>4)&0x0F)  
 114   2            {
 115   3            case 1:ReportError(Fault_DCDCOpen);break;
C51 COMPILER V9.60.0.0   SELFTEST                                                          05/15/2025 17:22:34 PAGE 3   

 116   3            default:ReportError(Fault_DCDCShort);
 117   3            }
 118   2          }
 119   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    540    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
