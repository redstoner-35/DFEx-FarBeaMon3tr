C51 COMPILER V9.60.0.0   SELFTEST                                                          05/18/2025 14:33:18 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SELFTEST
OBJECT MODULE PLACED IN .\Objects\SelfTest.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Logic\SelfTest.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODDP2 INCDIR(.\StdDriver
                    -\inc;.\Hardware;.\include\Hardware;.\include\Logic;.\include\Middleware;.\include\System) DEFINE(EnableStdGPIO) DEBUG PR
                    -INT(.\Listings\SelfTest.lst) TABS(2) OBJECT(.\Objects\SelfTest.obj)

line level    source

   1          #include "LEDMgmt.h"
   2          #include "delay.h"
   3          #include "ADCCfg.h"
   4          #include "BattDisplay.h"
   5          #include "ModeControl.h"
   6          #include "SelfTest.h"
   7          #include "LowVoltProt.h"
   8          #include "OutputChannel.h"
   9          
  10          //ÄÚ²¿±äÁ¿
  11          static xdata int ErrDisplayIndex; //´íÎóÏÔÊ¾¼ÆÊ±
  12          static xdata char ShortDetectTIM=0; //¶ÌÂ·¼à²â¼ÆÊ±Æ÷
  13          static xdata char ShortBlankTIM; //¶ÌÂ·blank¶¨Ê±Æ÷
  14          static code FaultCodeDef NonCriticalFault[]={ //·ÇÖÂÃüµÄ´íÎó´úÂë
  15            Fault_DCDCOpen,
  16            Fault_DCDCShort, //¿ªÂ·ºÍ¶ÌÂ·¿ÉÄÜÊÇÎó±¨£¬ÔÊÐíÏû³ý
  17            Fault_InputOVP
  18            };
  19            
  20          //Íâ²¿È«¾Ö²Î¿¼
  21          bit IsInputLimited;  //ÊäÈëÏÞÁ÷´¥·¢
  22          xdata FaultCodeDef ErrCode; //´íÎó´úÂë  
  23          
  24          //²éÑ¯´íÎóÊÇ·ñÖÂÃü
  25          bit IsErrorFatal(void)  
  26            {
  27   1        char i;
  28   1        for(i=0;i<sizeof(NonCriticalFault);i++)
  29   1          if(NonCriticalFault[i]==ErrCode)return 0;
  30   1        //Ñ°ÕÒÁËÄ¿Ç°ÒÑÓÐµÄ´íÎóÂë·¢ÏÖÊÇÖÂÃüÎÊÌâ
  31   1        return 1;
  32   1        }
  33          
  34          //±¨¸æ´íÎó
  35          void ReportError(FaultCodeDef Code)
  36            {
  37   1        ErrCode=Code;
  38   1        if(CurrentMode->ModeIdx==Mode_Fault)return;
  39   1        SwitchToGear(Mode_Fault);  //Ö¸Ê¾¹ÊÕÏ·¢Éú
  40   1        }
  41          
  42          //Ïû³ý´íÎó
  43          void ClearError(void)
  44            {
  45   1        ErrCode=Fault_None;
  46   1        SwitchToGear(Mode_OFF);
  47   1        }
  48          
  49          //´íÎóIDÏÔÊ¾¼ÆÊ±º¯Êý  
  50          void DisplayErrorTIMHandler(void) 
  51            {
  52   1        //Ã»ÓÐ´íÎó·¢Éú£¬¸´Î»¼ÆÊ±Æ÷
  53   1        if(ErrCode==Fault_None)ErrDisplayIndex=0;
C51 COMPILER V9.60.0.0   SELFTEST                                                          05/18/2025 14:33:18 PAGE 2   

  54   1        else //·¢Éú´íÎó£¬¿ªÊ¼¼ÆÊ±
  55   1          {
  56   2          ErrDisplayIndex++;
  57   2          if(ErrDisplayIndex>=(5+(6*(int)ErrCode)+10))ErrDisplayIndex=0; //ÉÏÏÞµ½ÁË£¬¿ªÊ¼·­×ª
  58   2          }
  59   1        }
  60          
  61          //³öÏÖ´íÎóÊ±ÏÔÊ¾DCDCµÄ´íÎóID
  62          void DisplayErrorIDHandler(void)
  63            {
  64   1        int buf;
  65   1        //ÏÈµ¼ÌáÊ¾ºì»ÆÂÌ½»ÌæÉÁ
  66   1        if(ErrDisplayIndex<5)
  67   1          {
  68   2          if(ErrDisplayIndex<3)LEDMode=(LEDStateDef)(ErrDisplayIndex+1);  
  69   2          else LEDMode=LED_OFF;
  70   2          }
  71   1        //ÉÁË¸Ö¸¶¨´ÎÊýÏÔÊ¾Err ID
  72   1        else if(ErrDisplayIndex<(5+(6*(int)ErrCode)))
  73   1          {
  74   2          buf=(ErrDisplayIndex-5)/3; 
  75   2          if(!(buf%2))LEDMode=LED_Red;
  76   2          else LEDMode=LED_OFF;  //°´ÕÕ´íÎóIDÉÁË¸Ö¸¶¨´ÎÊý
  77   2          }
  78   1        else LEDMode=LED_OFF; //LEDÏ¨Ãð
  79   1        }
  80          //ÄÚ²¿º¯Êý£¬¹ÊÕÏ¼ÆÊýÆ÷
  81          static char ErrTIMCounter(char buf,char Count)
  82            {
  83   1        //ÀÛ¼Ó¼ÆÊýÆ÷
  84   1        return buf<8?buf+Count:8;
  85   1        }
  86          
  87          //Êä³ö¹ÊÕÏ¼ì²â
  88          void OutputFaultDetect(void)
  89            {
  90   1        char buf,OErrID;
  91   1        //ÊäÈëMPPTÏÞÁ÷¼à²â
  92   1        if(Data.RawBattVolt<BeforeRawBattVolt) //µç³Ø¶¯Ì¬Ñ¹½µ¹ý´ó£¬½ûÖ¹µçÁ÷¼ÌÐøÔö¼Ó
  93   1          {
  94   2          IsInputLimited=1;
  95   2          BeforeRawBattVolt=-10; //¸´Î»²ÉÑù»º´æÈ·±£Ìõ¼þÖ»³ÉÁ¢Ò»´Î
  96   2          }
  97   1        else if(Data.FBInjectVolt<0.2&&Data.RawBattVolt<12.0&&Data.OutputVoltage>16)IsInputLimited=1; //µç³Ø×ÜµçÑ
             -¹µÍÓÚ12V£¬FB×¢ÈëÔË·ÅÊä³öÀ­µ½¸º¹ìÇÒÊä³ö´óÓÚ16V£¬ËµÃ÷ÊäÈëÏÞÁ÷´¥·¢
  98   1        else IsInputLimited=0;
  99   1        //Êä³ö¹ÊÕÏ¼à²â
 100   1        if(!GetIfOutputEnabled())ShortBlankTIM=0; //DCDC¹Ø±Õ
 101   1        else if(ShortBlankTIM<FaultBlankingInterval)ShortBlankTIM++; //Ê±¼äÎ´µ½²»ÔÊÐí¼à²â
 102   1        else  //¿ªÊ¼¼ì²â
 103   1          {   
 104   2          buf=ShortDetectTIM&0x0F; //È¡³ö¶¨Ê±Æ÷Öµ         
 105   2          //ÊäÈë¹ýÑ¹±£»¤
 106   2          if(Data.BatteryVoltage>4.4)ReportError(Fault_InputOVP); 
 107   2          //¶ÌÂ·¼ì²â  
 108   2          if(Data.OutputVoltage<14.6&&Data.FBInjectVolt>4.8) //Êä³ö¶ÌÂ·
 109   2            {
 110   3            buf=ErrTIMCounter(buf,2); //¼ÆÊ±Æ÷ÀÛ¼Æ
 111   3            OErrID=0;
 112   3            }
 113   2          //Êä³ö¿ªÂ·¼ì²â
 114   2          else if(Data.FBInjectVolt<0.5&&Data.OutputVoltage>22.5) 
C51 COMPILER V9.60.0.0   SELFTEST                                                          05/18/2025 14:33:18 PAGE 3   

 115   2            {
 116   3            buf=ErrTIMCounter(buf,1); //¼ÆÊ±Æ÷ÀÛ¼Æ
 117   3            OErrID=1;
 118   3            }
 119   2          else buf=buf>0?buf-1:0; //Ã»ÓÐ·¢Éú´íÎó£¬Çå³ý¼ÆÊýÆ÷
 120   2          //½øÐÐ¶¨Ê±Æ÷ÊýÖµµÄ»ØÐ´
 121   2          ShortDetectTIM=buf|(OErrID<<4);
 122   2          //×´Ì¬¼ì²â
 123   2          if(buf<8)return; //Ã»ÓÐ¹ÊÕÏ,Ìø¹ýÖ´ÐÐ
 124   2          switch((ShortDetectTIM>>4)&0x0F)  
 125   2            {
 126   3            case 1:ReportError(Fault_DCDCOpen);break;
 127   3            default:ReportError(Fault_DCDCShort);
 128   3            }
 129   2          }
 130   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    624    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
