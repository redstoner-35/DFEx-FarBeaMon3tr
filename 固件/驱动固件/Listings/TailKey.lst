C51 COMPILER V9.60.0.0   TAILKEY                                                           12/29/2024 10:00:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TAILKEY
OBJECT MODULE PLACED IN .\Objects\TailKey.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Hardware\TailKey.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include;.\StdD
                    -river\inc;.\Hardware) DEBUG PRINT(.\Listings\TailKey.lst) TABS(2) OBJECT(.\Objects\TailKey.obj)

line level    source

   1          #include "PinDefs.h"
   2          #include "cms8s6990.h"
   3          #include "GPIO.h"
   4          #include "delay.h"
   5          #include "TailKey.h"
   6          #include "SelfTest.h"
   7          #include "ADCCfg.h"
   8          #include "PWMCfg.h"
   9          
  10          //驱动尾按输入配置
  11          #define EnableMechTailKey //启用驱动的尾按输入
  12          
  13          //内部全局变量
  14          static xdata char TailKeyCount=0; //尾部按键按下的次数
  15          static char TailSenTIM; //延时启用尾部检测的定时器
  16          static bit IsTailKeyPressed=0;
  17          volatile bit IsPOSTKPressed=0; //正向尾按是否按下
  18          static volatile unsigned char IsEnterLowPowerMode=0xFF;
  19          
  20          //外部引用变量
  21          #ifndef EnableMechTailKey
              char TailKeyTIM=TailKeyRelTime+1;
              #else
  24          char TailKeyTIM;
  25          #endif
  26          
  27          #ifdef EnableMechTailKey
  28          //比较器中断
  29          void ACMP_IRQHandler(void)  interrupt ACMP_VECTOR 
  30          {
  31   1        HShuntSelIOP&=~(0x01<<HShuntSelIOx);
  32   1        LShuntSelIOP&=~(0x01<<LShuntSelIOx);
  33   1        RevProtIOP&=~(0x01<<RevProtIOx);
  34   1        DCDCENIOP&=~(0x01<<DCDCENIOx); //立即拉掉DCDCEN
  35   1        RedLEDIOP&=~(0x01<<RedLEDIOx);
  36   1        GreenLEDIOP&=~(0x01<<GreenLEDIOx); //令LED立即熄灭
  37   1        IsEnterLowPowerMode=0x00;
  38   1        //响应结束
  39   1        CNIF=0; 
  40   1      } 
  41          //使能尾按处理
  42          static void EnableTailDetect(void)
  43            {
  44   1        C0CON0|=0x80; //令C0EN=1，比较器开始运行
  45   1        delay_ms(20); 
  46   1        CNIF=0; //延迟20mS后再清除Flag（打开比较器中断前需要清除Flag）
  47   1        CNIE=0x01; //使能ACMP0中断，尾按检测激活
  48   1        }
  49          #endif
  50            
  51          void TailKey_Init(void) 
  52            {
  53   1        C0CON0=0x09; //比较器调节模式禁止，正输入为C0P1，负输入为内部REF  
  54   1        C0CON2=0x19; //比较器配置为使能滤波功能，滤波时间常数为256*1/48MHz=5.33uS，正输出极性
C51 COMPILER V9.60.0.0   TAILKEY                                                           12/29/2024 10:00:10 PAGE 2   

  55   1        C0HYS=0x00; //禁用迟滞
  56   1        CNVRCON=0x38; //比较器负向输入的基准电压为内部1.2V带隙基准按照10/20比例分压得到0.6V
  57   1        CNFBCON=0x05; //使能比较器0的刹车功能，在负边沿时禁止PWM输出
  58   1        EIP1=0x80; //比较器中断必须实时响应所以设置为极高优先级
  59   1        }
  60          
  61          //尾部开关所需要的模拟比较器初始化,以及正向开关检测(上电的时候用的)
  62          void TailKey_POR_Init(void)
  63            {
  64   1        #ifdef EnableMechTailKey
  65   1        unsigned char wait;
  66   1        extern bit IsPosTailKey;
  67   1        bit TKState=1;
  68   1        //初始化比较器并复位尾按计时器
  69   1        TailKey_Init(); 
  70   1        TailKeyTIM=0; 
  71   1        //使能尾按检测开始检测正向开关的动作
  72   1        if(!IsPosTailKey)return; //配置电阻设置为反向开关，退出检测
  73   1        wait=30;
  74   1        C0CON0|=0x80; //令C0EN=1，比较器开始运行
  75   1        do
  76   1          {   
  77   2          //引入延时
  78   2          delay_ms(7);
  79   2          //检测比较器状态
  80   2          IsEnterLowPowerMode<<=1;
  81   2          if(C0CON1&0x80)IsEnterLowPowerMode++;
  82   2          //根据开关状态进行动作  
  83   2          if(IsEnterLowPowerMode==0xFF)
  84   2            {
  85   3            TKState=1;
  86   3            wait--; //尾按正常按下通电，递减计时器
  87   3            }
  88   2          else if(!(IsEnterLowPowerMode&0x1F)) //按键松开足够时间说明是点动操作     
  89   2            {
  90   3            wait=30; //尾按按下，复位定时器
  91   3            if(!TKState)continue; //尾按当前没有通电足够长的时间，不允许判断
  92   3            IsPOSTKPressed=1;
  93   3            IsEnterLowPowerMode=0; //清除按键缓存等待按键确实按下再动作
  94   3            TailKeyCount++; //增加有效的按键次数
  95   3            TKState=0; //标记开关松开
  96   3            }   
  97   2          }
  98   1        while(wait);
  99   1        //检测完毕的后处理
 100   1        TailKeyTIM=IsPOSTKPressed?TailKeyRelTime:TailKeyRelTime+1; //如果按键没有按下则让系统立即点亮，按键按下则
             -直接进行处理后再点亮
 101   1        C0CON0&=0x7F; //令C0EN=0，比较器停止运行  
 102   1        #endif
 103   1        }
 104          
 105          //获取尾按按下的次数
 106          char GetTailKeyCount(void)
 107            {
 108   1        char buf;
 109   1        if(!IsTailKeyPressed)return 0;
 110   1        else 
 111   1          {
 112   2          buf=TailKeyCount;
 113   2          TailKeyCount=0;
 114   2          IsTailKeyPressed=false;
 115   2          }
C51 COMPILER V9.60.0.0   TAILKEY                                                           12/29/2024 10:00:10 PAGE 3   

 116   1        return buf;
 117   1        } 
 118          
 119          //尾按计时器
 120          void TailKeyCounter(void)
 121            {
 122   1        //手电开启状态下才进行尾按检测
 123   1        #ifdef EnableMechTailKey
 124   1        if(CurrentMode->ModeIdx==Mode_OFF||CurrentMode->ModeIdx==Mode_Fault)
 125   1          {
 126   2          CNIE=0x00; //关闭比较器中断
 127   2          C0CON0&=0x7F; //令C0EN=0，比较器停止运行
 128   2          TailSenTIM=0;     
 129   2          }
 130   1        else if(TailSenTIM<3)TailSenTIM++;
 131   1        else if(TailSenTIM==3)
 132   1          {
 133   2          if(Data.RawBattVolt>5.8)EnableTailDetect(); //尾按监测机制需要5.8V以上的电压才能有足够的置信度
 134   2          TailSenTIM++;
 135   2          }
 136   1        //尾按开关按下之后用于监测连续多次按下的计时模块
 137   1        if(TailKeyTIM<TailKeyRelTime)TailKeyTIM++;
 138   1        else if(TailKeyTIM==TailKeyRelTime)
 139   1          {
 140   2          TailKeyTIM++;
 141   2          if(TailKeyCount>0)IsTailKeyPressed=1;
 142   2          }
 143   1        #endif
 144   1        } 
 145            
 146          //尾按逻辑处理  
 147          void TailKey_Handler(void)
 148            {
 149   1        #ifdef EnableMechTailKey
 150   1        //尾按被禁用或者没有按下，退出处理
 151   1        if(!(C0CON0&0x80)||IsEnterLowPowerMode)return;
 152   1        //循环等待按钮重新接通恢复供电
 153   1        do
 154   1          {
 155   2          delay_ms(5);
 156   2          IsEnterLowPowerMode<<=1;
 157   2          if(C0CON1&0x80)IsEnterLowPowerMode++;
 158   2          }     
 159   1        while(IsEnterLowPowerMode!=0xFF);
 160   1        //恢复供电，进行按键逻辑处理
 161   1        PWM_Enable(); //重新使能PWM   
 162   1        TailKeyCount++;
 163   1        TailKeyTIM=0;  //尾按按键按下，发生事件复位计时器
 164   1        #endif
 165   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    403    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   TAILKEY                                                           12/29/2024 10:00:10 PAGE 4   

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
