C51 COMPILER V9.60.0.0   DELAY                                                             04/29/2025 17:16:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DELAY
OBJECT MODULE PLACED IN .\Objects\delay.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Hardware\delay.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODDP2 INCDIR(.\StdDriver
                    -\inc;.\Hardware;.\include\Hardware;.\include\Logic;.\include\Middleware;.\include\System) DEFINE(EnableStdGPIO) DEBUG PR
                    -INT(.\Listings\delay.lst) TABS(2) OBJECT(.\Objects\delay.obj)

line level    source

   1          #include "cms8s6990.h"
   2          #include "delay.h"
   3          #include "PinDefs.h"
   4          #include "SideKey.h"
   5          #include "GPIO.h"
   6          
   7          volatile bit SysHFBitFlag; //高频心跳Flag(65.5mS)
   8          volatile bit LFStrobeFlag; //低频爆闪Flag(125mS)
   9          volatile bit IsT0OVF; //T0已溢出
  10          volatile bit StrobeFlag; //爆闪Flag
  11          
  12          //8Hz定时器初始化
  13          void SetSystemHBTimer(bit IsEnable)
  14            {
  15   1        if(!IsEnable) 
  16   1          {
  17   2          T2CON=0x00; //禁用T2定时器
  18   2          IE&=~0x20; //禁用T2中断
  19   2          return;
  20   2          }
  21   1        //配置定时器模式      
  22   1        CCEN=0x00; //关闭比较和捕获
  23   1        RLDH=0x0B;
  24   1        RLDL=0xDB; //将重装载值设置为产生31.25mS延迟(1/32秒)，计算公式为65535-(48/24(0.5uS)=2000*31.25mS)=3035[0x
             -0BDB]
  25   1        TH2=0x5D;
  26   1        TL2=0x66; //将计数器设置为产生31.25mS延迟的初值
  27   1        //启用中断
  28   1        IE|=0x20;   //令ET2=1，启用T2中断
  29   1        T2IF=0x00; //清零T2中断
  30   1        T2IE=0x80; //令T2OVIE=1，启用T2 OVF中断
  31   1        //启动定时器
  32   1        SysHFBitFlag=0;
  33   1        LFStrobeFlag=0;
  34   1        StrobeFlag=0;  //复位所有flag
  35   1        T2CON=0x91; //设置T2时钟源为fSys/24=1MHz，定时器立即启动
  36   1        }
  37          
  38          #ifdef EnableHBCheck
              //检查心跳定时器是否就绪
              void CheckIfHBTIMIsReady(void)
                {
                //函数声明
                void SetHBLEDState(bit State);
                //变量
                char retry=100;
                //开始检查之前复位flag并置起LED
                SetHBLEDState(1);
                SysHFBitFlag=0;
                //循环等待flag置起
                do
                  {
                  delay_ms(1);
C51 COMPILER V9.60.0.0   DELAY                                                             04/29/2025 17:16:19 PAGE 2   

                  if(SysHFBitFlag)return; //定时器已启动，退出
                  retry--;
                  }
                while(retry);
                //定时器等待超时,锁死
                while(1);
                }
              #endif
  61            
  62          //系统心跳定时器的中断处理  
  63          void Timer2_IRQHandler(void) interrupt TMR2_VECTOR
  64          { 
  65   1        T2IF=0x00; //清零T2中断
  66   1        //进行爆闪2分频
  67   1        StrobeFlag=~StrobeFlag; //TStrobe=31.25*2=62.5mS
  68   1        if(StrobeFlag)
  69   1          {
  70   2          SysHFBitFlag=1;  //每62.5mS将flag置1
  71   2          LFStrobeFlag=~LFStrobeFlag; //翻转低频爆闪flag
  72   2          }
  73   1      }   
  74            
  75          //软件延时定时器的中断处理
  76          void Timer0_IRQHandler(void) interrupt TMR0_VECTOR  //0x0B 
  77          {
  78   1        TCON&=0xEF; //清除溢出标记位
  79   1        IsT0OVF=1;
  80   1      }   
  81            
  82          //延时初始化
  83          void delay_init()
  84            { 
  85   1        TCON&=0xCF; //清除溢出标记位，关闭定时器
  86   1        TMOD&=0xF0;
  87   1        TMOD|=0x01; //T0设置为使用Fext,16bit向上计数模式
  88   1        TH0=0x00;
  89   1        TL0=0x00; //初始化数值
  90   1        IE=0x82; //令ET0=1，启用定时中断,EA=1，启用全局总中断
  91   1        }
  92          #ifdef EnableMicroSecDelay
              //uS延迟
              void delay_us(int us)
                {
                bit IsEA=EA;
                us<<=2; //左移两位,将uS*4得到总周期值
                us=0xFFFF-us; //得到计数器值
                //装载定时器值
                TH0=(us>>8)&0xFF;
                TL0=us&0xFF; 
                IE&=0x7D; //令ET0,EA=0，关闭定时中断和全局总中断开关
                //启动定时器开始倒计时
                TCON|=0x10; //TR0=1,定时器开始计时  
                while(!(TCON&0x20)); //等待直到T0溢出
                //计时结束，复位所有标志位并重新打开中断
                TCON&=0xCF; //清除溢出标记位，关闭定时器
                if(IsEA)IE|=0x82;
                else IE|=0x02;
                }
              #endif
 112          //1ms延时
 113          void delay_ms(int ms)
 114            {
C51 COMPILER V9.60.0.0   DELAY                                                             04/29/2025 17:16:19 PAGE 3   

 115   1        unsigned long CNT;
 116   1        int repcounter=0;
 117   1        //计算定时器重装值
 118   1        if(ms==0)return;
 119   1        do
 120   1          {
 121   2          repcounter++; //重复计数器+1
 122   2          CNT=(long)ms*4000; //T0一个周期是48/12=4MHz=0.25uS
 123   2          CNT/=(long)repcounter; //除以重复次数得到单次计数值
 124   2          }
 125   1        while(CNT>=65535); //反复循环确保定时器值小于65535
 126   1        CNT=0xFFFF-CNT; //计算结束，将16bit计数器满的值加载到定时器内
 127   1        //开始进行单次或多次倒计时
 128   1        do
 129   1          {     
 130   2          //装载定时器值
 131   2          TH0=(CNT>>8)&0xFF;
 132   2          TL0=CNT&0xFF; 
 133   2          IsT0OVF=0; //复位标志位
 134   2          //启动定时器开始倒计时
 135   2          TCON|=0x10; //TR0=1,定时器开始计时  
 136   2          while(!(TCON&0x20)&&!IsT0OVF); //等待直到T0溢出
 137   2          //计时结束，准备进行下一轮
 138   2          TCON&=0xCF; //清除溢出标记位，关闭定时器
 139   2          repcounter--; //重复次数-1
 140   2          }
 141   1        while(repcounter);
 142   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    267    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
