C51 COMPILER V9.60.0.0   TAILMEMORY                                                        12/24/2024 18:55:48 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TAILMEMORY
OBJECT MODULE PLACED IN .\Objects\TailMemory.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Logic\TailMemory.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include;.\StdD
                    -river\inc;.\Hardware) DEBUG PRINT(.\Listings\TailMemory.lst) TABS(2) OBJECT(.\Objects\TailMemory.obj)

line level    source

   1          #include "ModeControl.h"
   2          #include "Flash.h"
   3          #include "TailKey.h"
   4          
   5          //不允许记忆的挡位名单
   6          code ModeIdxDef NonMemList[]={Mode_Turbo,Mode_Strobe,Mode_SOS};
   7          
   8          //在Flash内寻找上一次关机之前的结果
   9          static int SearchForLastMode(ModeIdxDef *Result)
  10            {
  11   1        int i;
  12   1        char buf;
  13   1        for(i=512;i<1020;i++)
  14   1          {
  15   2          Flash_Operation(Flash_Read,i,&buf);
  16   2          if(buf<1||buf>11)return i; //找到空的地方
  17   2          else *Result=(ModeIdxDef)(buf-1); //当前还未抵达最后一个模式    
  18   2          }
  19   1        //找了一圈啥也没找到
  20   1        *Result=Mode_OFF;
  21   1        return i;
  22   1        }
  23          //挡位记忆名单的匹配
  24          static ModeIdxDef ModeMemoryLookup(ModeIdxDef Mode,ModeIdxDef LastMode) 
  25            {
  26   1        char i;
  27   1        if(Mode==Mode_Fault)Mode=Mode_OFF; //回到关机状态
  28   1        else for(i=0;i<sizeof(NonMemList);i++)if(Mode==NonMemList[i])
  29   1          {
  30   2          if(LastMode!=Mode_OFF)Mode=LastMode;
  31   2          else Mode=Mode_Low; //如果上次记忆是关机状态，则配置为低亮档
  32   2          }
  33   1        //计算完毕
  34   1        return Mode;
  35   1        }
  36          
  37          //上电时进行尾部按键记忆的recall
  38          void TailMemory_Recall(void)
  39            {
  40   1        ModeIdxDef ModeBuf;
  41   1        //读取EEPROM找到最新的记忆结果
  42   1        SetFlashState(1);
  43   1        SearchForLastMode(&ModeBuf); //寻找上次结束的结果
  44   1        SwitchToGear(ModeMemoryLookup(ModeBuf,Mode_OFF)); //恢复到上个挡位
  45   1        SetFlashState(0); //关闭中断
  46   1        }
  47          
  48          //数据区保存
  49          void TailMemory_Save(ModeIdxDef Mode)
  50            {
  51   1        int Idx;
  52   1        ModeIdxDef LastMode;
  53   1        char buf;
  54   1        //进行遍历读取
C51 COMPILER V9.60.0.0   TAILMEMORY                                                        12/24/2024 18:55:48 PAGE 2   

  55   1        SetFlashState(1);
  56   1        Idx=SearchForLastMode(&LastMode);
  57   1        //比对数据
  58   1        ModeMemoryLookup(Mode,LastMode); //进行名单匹配
  59   1        if(LastMode==(unsigned char)Mode) //当前模式记忆模块里面数据和目标要写入的数据相同
  60   1          {
  61   2          SetFlashState(0);
  62   2          return;
  63   2          }
  64   1        //存储区已经写满了，擦除
  65   1        if(Idx==1020)
  66   1          {
  67   2          Idx=512; //回到存储结构的头部开始写入
  68   2          Flash_Operation(Flash_Erase,Idx,&buf);
  69   2          }
  70   1        //开始写入数据
  71   1        buf=((char)Mode)+1;
  72   1        Flash_Operation(Flash_Write,Idx,&buf);
  73   1        SetFlashState(0); //写入完毕锁住Flash
  74   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    274    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
