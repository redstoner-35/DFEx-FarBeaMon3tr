C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OUTPUTCHANNEL
OBJECT MODULE PLACED IN .\Objects\OutputChannel.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Hardware\OutputChannel.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODDP2 INCDIR(.\S
                    -tdDriver\inc;.\Hardware;.\include\Hardware;.\include\Logic;.\include\Middleware;.\include\System) DEFINE(EnableStdGPIO) 
                    -DEBUG PRINT(.\Listings\OutputChannel.lst) TABS(2) OBJECT(.\Objects\OutputChannel.obj)

line level    source

   1          #include "cms8s6990.h"
   2          #include "PinDefs.h"
   3          #include "GPIO.h"
   4          #include "PWMCfg.h"
   5          #include "delay.h"
   6          #include "SpecialMode.h"
   7          #include "TempControl.h"
   8          #include "OutputChannel.h"
   9          #include "ADCCfg.h"
  10          #include "SelfTest.h"
  11          
  12          //ÄÚ²¿SFR
  13          sbit AUXEN=AUXENIOP^AUXENIOx; //¸¨Öú6V DCDCÊ¹ÄÜ
  14          sbit PWMDACEN=PWMDACENIOP^PWMDACENIOx; //PWMDACÊ¹ÄÜ
  15          sbit SYSHBLED=SYSHBLEDIOP^SYSHBLEDIOx; //ÐÄÌøLED
  16          sbit BOOSTRUN=BOOSTRUNIOP^BOOSTRUNIOx; //LTC3787µÄEN
  17          sbit LEDMOS=LEDNegMOSIOP^LEDNegMOSIOx; //LEDMOSFET
  18          
  19          //Íâ²¿µçÁ÷ÅäÖÃ²Î¿¼
  20          xdata volatile int Current; //Ä¿±êµçÁ÷(mA)
  21          xdata int CurrentBuf; //´æ´¢µ±Ç°ÒÑ¾­ÉÏ´«µÄµçÁ÷Öµ 
  22          bit IsCurrentRampUp;  //µçÁ÷ÕýÔÚÉÏÉý¹ý³ÌÖÐµÄ±ê¼ÇÎ»£¨ÓÃÓÚºÍMPPTÊÔÌ½Áª¶¯£©
  23          
  24          //ÄÚ²¿±äÁ¿
  25          static bit IsEnableSlowILEDRamp; //±êÖ¾Î»£¬ÊÇ·ñÆôÓÃÂýËÙµçÁ÷Ð±ÂÊ¿ØÖÆ
  26          static xdata char PreChargeFSMTimer; //Ô¤³äµç×´Ì¬»ú¼ÆÊ±Æ÷
  27          static xdata OutChFSMStateDef OutputFSMState; //Êä³ö¿ØÖÆ×´Ì¬»ú
  28          static xdata char HBTimer; //ÐÄÌø¼ÆÊ±Æ÷
  29          
  30          /*********************************************************************************************************
             -************
  31          Êä³öÍ¨µÀ¿ØÖÆÆ÷ËùÊ¹ÓÃµÄÄÚ²¿º¯Êý£¬½öÄÜÔÚ¸ÃÎÄ¼þÄÚµ÷ÓÃ¡£
  32          **********************************************************************************************************
             -***********/
  33          
  34          //ÄÚ²¿ÓÃÓÚ¼ÆËãPWMDACÕ¼¿Õ±ÈµÄº¯Êý  
  35          static float Duty_Calc(int CurrentInput)
  36            {
  37   1        float buf;
  38   1        //¼ÆËãÊµ¼ÊÕ¼¿Õ±È
  39   1        buf=(float)CurrentInput*(float)MainChannelShuntmOhm; //ÊäÈë´«½øÀ´µÄµçÁ÷(mA)²¢³ËÒÔ¼ìÁ÷µç×è×èÖµ(mR)µÃµ½¼ìÁ÷
             -µç×è´¦µÄÄ¿±êµçÑ¹(uV)
  40   1        buf*=(float)0.0015; //uV×ªmV²¢¸ù¾Ý1.5mA per LSB»»ËãµÃµ½Êµ¼ÊµÄµçÁ÷Öµ
  41   1        buf*=CurrentSenseOpAmpGain; //½«¼ìÁ÷µç×è´¦µÄÄ¿±êµçÑ¹(mV)³ËÒÔ¼ìÁ÷·Å´óÆ÷µÄÔöÒæµÃµ½ÔË·Å¶ËµÄÕû¶¨Öµ
  42   1        buf/=Data.MCUVDD*(float)1000; //¼ÆËã³öÄ¿±êDACÊä³öµçÑ¹ºÍPWMDAC»º³åÆ÷¹©µçµçÑ¹(MCUVDD)Ö®¼äµÄ±ÈÖµ
  43   1        buf*=102; //×ª»»Îª°Ù·Ö±È(³ËÒÔ102²¹³¥µôÏµÍ³µÄ»»ËãÎó²î)
  44   1        //½á¹ûÊä³ö  
  45   1        return buf>100?100:buf;
  46   1        }
  47            
  48          /*********************************************************************************************************
             -************
  49          Êä³öÍ¨µÀ¿ØÖÆÆ÷ËùÊ¹ÓÃµÄÍâ²¿º¯Êý£¬¿ÉÒÔÔÚÆäËûµØ·½µ÷ÓÃ¡£
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 2   

  50          **********************************************************************************************************
             -***********/
  51          
  52          //³õÊ¼»¯º¯Êý
  53          void OutputChannel_Init(void)
  54            {
  55   1        GPIOCfgDef OCInitCfg;
  56   1        //ÉèÖÃ½á¹¹Ìå
  57   1        OCInitCfg.Mode=GPIO_Out_PP;
  58   1        OCInitCfg.Slew=GPIO_Fast_Slew;    
  59   1        OCInitCfg.DRVCurrent=GPIO_High_Current; //ÍÆMOSFET,ÐèÒª¸ßÉÏÉýÐ±ÂÊ
  60   1        //³õÊ¼»¯bit
  61   1        AUXEN=0;
  62   1        BOOSTRUN=0;
  63   1        PWMDACEN=0;
  64   1        SYSHBLED=0; //ËùÓÐbit¶¼Îª0
  65   1        //¿ªÊ¼ÅäÖÃIO  
  66   1        GPIO_ConfigGPIOMode(PWMDACENIOG,GPIOMask(PWMDACENIOx),&OCInitCfg);  
  67   1        GPIO_ConfigGPIOMode(AUXENIOG,GPIOMask(AUXENIOx),&OCInitCfg);      
  68   1        GPIO_ConfigGPIOMode(BOOSTRUNIOG,GPIOMask(BOOSTRUNIOx),&OCInitCfg);    
  69   1        GPIO_ConfigGPIOMode(LEDNegMOSIOG,GPIOMask(LEDNegMOSIOx),&OCInitCfg);
  70   1        GPIO_ConfigGPIOMode(SYSHBLEDIOG,GPIOMask(SYSHBLEDIOx),&OCInitCfg);    
  71   1        //µ÷ÓÃ¸´Î»º¯ÊýÖØÖÃËùÓÐ×´Ì¬
  72   1        OutputChannel_DeInit();
  73   1        }
  74          
  75          //ÄÚÁªº¯Êý£¬ÉèÖÃÐÄÌøLED
  76          //void SetHBLEDState(bit State)
  77          //  {
  78          //  SYSHBLED=State;
  79          //  } 
  80            
  81          //Ô¤³äµç×´Ì¬»ú¼ÆÊ±Æ÷
  82          void OCFSM_TIMHandler(void)
  83            {
  84   1        //ÐÄÌøLED¿ØÖÆ 
  85   1        if(CurrentMode->ModeIdx==Mode_Fault) //·¢Éú¹ÊÕÏÊ±HB¿ìÉÁ
  86   1          SYSHBLED=SYSHBLED?0:1; //·­×ªLED
  87   1        else if(GetIfOutputEnabled())//Êä³öÒÑÆôÓÃ£¬LEDÅäÖÃÎª1
  88   1          {
  89   2          //Êä³öÏµÍ³´¦ÓÚ´ý»ú×´Ì¬£¬Êä³öLEDÂýÉÁ
  90   2          if(OutputFSMState==OutCH_OutputIdle)
  91   2            {
  92   3            SYSHBLED=HBTimer==3?1:0; //´ý»ú×´Ì¬ÏÂÃ¿¸ô°ëÃë¿ìÉÁÒ»´Î
  93   3            if(HBTimer<4)HBTimer++;
  94   3            else HBTimer=0;
  95   3            }
  96   2          //ÆäÓà×´Ì¬ÏÂLED³£ÁÁ
  97   2          else SYSHBLED=1;
  98   2          }     
  99   1        else //´ý»ú×´Ì¬ÏÂÂýÉÁ
 100   1          {
 101   2          if(HBTimer<4)HBTimer++;
 102   2          else
 103   2            {
 104   3            SYSHBLED=SYSHBLED?0:1; //·­×ªLED
 105   3            HBTimer=0;
 106   3            }
 107   2          }
 108   1        //×´Ì¬»ú¼ÆÊ±Æ÷
 109   1        if(PreChargeFSMTimer>0)PreChargeFSMTimer--;
 110   1        } 
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 3   

 111            
 112          //Êä³öÍ¨µÀ¸´Î»
 113          void OutputChannel_DeInit(void)
 114            {
 115   1        BOOSTRUN=0;
 116   1        AUXEN=0;
 117   1        LEDMOS=0;
 118   1        PWMDACEN=0;
 119   1        SYSHBLED=0; //ËùÓÐbit¶¼Îª0
 120   1        //ÏµÍ³ÉÏµçÊ±µçÁ÷ÅäÖÃÎª0
 121   1        Current=0;
 122   1        CurrentBuf=0;
 123   1        IsCurrentRampUp=0;
 124   1        IsEnableSlowILEDRamp=0;
 125   1        //¸´Î»×´Ì¬»ú
 126   1        HBTimer=0;
 127   1        OutputFSMState=OutCH_Standby;
 128   1        } 
 129          
 130          //Íâ²¿»ñÈ¡Êä³öÊÇ·ñÕý³£ÆôÓÃµÄº¯Êý
 131          bit GetIfOutputEnabled(void)  
 132            {
 133   1        if(OutputFSMState==OutCH_OutputEnabled)return 1;
 134   1        if(OutputFSMState==OutCH_SubmitDuty)return 1;
 135   1        //·ñÔò·µ»Ø0
 136   1        return 0;
 137   1        }
 138          
 139          //»ñÈ¡ÏµÍ³ÊÇ·ñÔÚ°²È«¹Ø»ú½×¶Î
 140          bit GetIfSystemInPOFFSeq(void)
 141            {
 142   1        //Èç¹ûÏµÍ³´¦ÔÚÈí¹Ø»úµÄµÈ´ý½×¶ÎÔò²»ÔÊÐí¹Ø±Õ  
 143   1        if(OutputFSMState==OutCH_WaitVOUTDecay)return 1;
 144   1        if(OutputFSMState==OutCH_GracefulShut)return 1;   
 145   1        //ÏµÍ³ÒÑ¾­¹Ø±Õ£¬·µ»Ø0
 146   1        return 0;
 147   1        } 
 148            
 149          //Êä³öÍ¨µÀÊÔÔËÐÐ
 150          void OutputChannel_TestRun(void)
 151            {
 152   1        char retry=100;
 153   1        bit IsDCDCOV=0;
 154   1        //´ò¿ª¸¨ÖúµçÔ´ºÍPWMDAC
 155   1        AUXEN=1;
 156   1        PWMDACEN=1;
 157   1        PWM_ForceEnableOut(1);
 158   1        //ÑÓÊ±40mSºó¼ì²âµçÑ¹£¬Èç¹ûµçÑ¹´óÓÚ8VÔòÕý³£Æô¶¯½øÐÐ¼ì²â
 159   1        delay_ms(40);
 160   1        SystemTelemHandler();
 161   1        if(Data.RawBattVolt>8)BOOSTRUN=1; //Áî3787EN=1£¬Æô¶¯Êä³ö
 162   1        else 
 163   1          {
 164   2          PWM_ForceEnableOut(0);
 165   2          OutputChannel_DeInit(); //¹Ø±ÕPWMÊä³ö²¢¸´Î»Êä³öÍ¨µÀ
 166   2          return;
 167   2          }
 168   1        //¼ì²éÊä³ö×´Ì¬
 169   1        do
 170   1          {
 171   2          SystemTelemHandler();
 172   2          if(Data.OutputVoltage>16.5)IsDCDCOV=1; //±ê¼Ç³öÏÖ¹ýÑ¹
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 4   

 173   2          else if(Data.OutputVoltage>14.0)
 174   2            {
 175   3            //¼ì²éÍ¨¹ý£¬¹Ø±ÕDCDC
 176   3            BOOSTRUN=0;
 177   3            delay_ms(5);
 178   3            //¸´Î»PWMDAC
 179   3            PWMDACEN=0;
 180   3            PWM_ForceEnableOut(0);
 181   3            //¹Ø±Õ¸¨ÖúµçÔ´
 182   3            AUXEN=0;  
 183   3            return;
 184   3            }
 185   2          //¼ì²éÊ§°Ü
 186   2          delay_ms(5);
 187   2          retry--;
 188   2          }
 189   1        while(retry>0);
 190   1        //DCDC¼ì²é³¬Ê±£¬±¨¸æ´íÎó
 191   1        ReportError(IsDCDCOV?Fault_DCDCPreChargeFailed:Fault_DCDCFailedToStart);
 192   1        }
 193          
 194          //Êä³öÍ¨µÀ¼ÆËã
 195          void OutputChannel_Calc(void)
 196            {
 197   1        int TargetCurrent,ILIM;
 198   1        extern bit IsBatteryAlert;
 199   1        //¶ÁÈ¡Ä¿±êµçÁ÷
 200   1        TargetCurrent=Current;
 201   1        if(Current>0) //µçÁ÷´óÓÚ0ËµÃ÷ÊÇÓÐÐ§Êä³öÖ´ÐÐÎÂ¿Ø¼ÆËã
 202   1          {
 203   2          //ÎÂ¿Ø¼ÆËã
 204   2          ILIM=ThermalILIMCalc();
 205   2          if(TargetCurrent>ILIM)TargetCurrent=ILIM; //ÎÂ¿Ø·´À¡µÄÔËÐÐµçÁ÷³¬¹ýÄ¿±êÖµ£¬½øÐÐÏÞÁ÷
 206   2          }
 207   1        //½øÐÐÊä³öÍ¨µÀ×´Ì¬»ú¹ÜÀí
 208   1        switch(OutputFSMState)
 209   1          {
 210   2          //Êä³öÍ¨µÀ¹ÊÕÏ  
 211   2          case OutCH_PreChargeFailed:
 212   2             OutputChannel_DeInit(); //Ö´ÐÐÊä³ö¸´Î»
 213   2             break; 
 214   2          //Êä³öÍ¨µÀ´ý»ú×´Ì¬
 215   2          case OutCH_Standby:
 216   2             //¸´Î»DCDC¿ØÖÆ
 217   2             BOOSTRUN=0;
 218   2             AUXEN=0;
 219   2             LEDMOS=0;
 220   2             PWMDACEN=0;
 221   2             //¸´Î»±ê¼ÇÎ»
 222   2             IsCurrentRampUp=0;
 223   2             //¸´Î»PWMDAC
 224   2             if(PreChargeDACDuty||PWMDuty>0)
 225   2              {
 226   3              PreChargeDACDuty=0;
 227   3              PWMDuty=0;
 228   3              IsNeedToUploadPWM=1;
 229   3              }
 230   2             //Èç¹ûµçÁ÷·¢Éú±ä¸üÔò½øÈëÆô¶¯×´Ì¬
 231   2             if(TargetCurrent>0)OutputFSMState=OutCH_PWMDACPreCharge;
 232   2             break;
 233   2          //Æô¶¯²½Öè1£¬ËÍ³öPWMDAC
 234   2          case OutCH_PWMDACPreCharge:
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 5   

 235   2             //Æô¶¯µçÁ÷Õû¶¨DAC
 236   2             PWMDACEN=1;
 237   2             //ÅäÖÃPWMDACÕ¼¿Õ±È
 238   2             CurrentBuf=TargetCurrent>CalcIREFValue(1500)?CalcIREFValue(1500):TargetCurrent;
 239   2             PWMDuty=Duty_Calc(CurrentBuf);  //ÅäÖÃÁ÷³ÌÊÇÈç¹ûµ±Ç°µçÁ÷´óÓÚ1.5A£¬ÔòÇ¯Î»µ½1.5A£¬È»ºóÓÃÕâ¸ö³õÖµÅäÖÃPWMD
             -AC
 240   2             //Æô¶¯CVÏÞÑ¹»·DAC
 241   2             PreChargeDACDuty=0x82A; //0x82A=87.128%=11.29-0.4815*14.4->(0.87128*5)
 242   2             //ÉÏ´«Õ¼¿Õ±È²¢Ìø×ªµ½ÏÂÒ»²½(Æô¶¯Ö÷DCDC¸¨ÖúPSU)
 243   2             IsNeedToUploadPWM=1;
 244   2             OutputFSMState=OutCH_StartAUXPSU;
 245   2             break;
 246   2          //Æô¶¯²½Öè2£¬Æô¶¯¸¨ÖúPSU£¨¸øLTC3787¹©µçµÄµçÔ´£©
 247   2          case OutCH_StartAUXPSU:
 248   2             //µÈ´ýPWMÊä³ö
 249   2             if(IsNeedToUploadPWM)break;
 250   2             delay_ms(20); //ÑÓÊ±20mS
 251   2             //Æô¶¯¸¨ÖúµçÔ´²¢Ìø×ªµ½ÏÂ¸ö×´Ì¬
 252   2             AUXEN=1;
 253   2             PreChargeFSMTimer=16; //ÉèÖÃ¼ÆÊ±Æ÷×î¶àµÈ´ý2Ãë
 254   2             OutputFSMState=OutCH_EnableBoost;
 255   2             break;
 256   2          //Æô¶¯²½Öè3£¬Æô¶¯Ö÷DCDC²¢¼ì²éÊä³öÊÇ·ñÕý³£
 257   2          case OutCH_EnableBoost:
 258   2            //Áî3787EN=1£¬Ö÷Boost¿ªÊ¼Êä³öÈ»ºó¼ì²âµçÑ¹×´Ì¬
 259   2            BOOSTRUN=1;
 260   2            if(Data.OutputVoltage>14.0)OutputFSMState=OutCH_ReleasePreCharge; //µçÑ¹ÆðÀ´ÁË£¬¼ÌÐøÆô¶¯Á÷³Ì
 261   2            //µÈ´ý³¬Ê±ºó±¨´í
 262   2            if(PreChargeFSMTimer>0)break;
 263   2            ReportError(Fault_DCDCFailedToStart);
 264   2            OutputFSMState=OutCH_PreChargeFailed;
 265   2            break;
 266   2          //Æô¶¯²½Öè4£¬Öð²½ÏÂµ÷Ô¤³äPWMDACÌ§ÉýÊä³öµçÑ¹
 267   2          case OutCH_ReleasePreCharge:
 268   2            //½ÓÍ¨LED¸º¼«FET£¬LED¿ªÊ¼·¢¹â
 269   2            LEDMOS=1;
 270   2            //Èç¹ûµçÁ÷Îª0Ôò¿ªÊ¼½øÈë·Åµç½×¶Î
 271   2            if(TargetCurrent==0)OutputFSMState=OutCH_GracefulShut;
 272   2            //Èç¹ûÕ¼¿Õ±Èµ÷Õûµ½0ÁËÔò½øÈëÌáÉýÊä³öµçÁ÷µ½Ä¿±êÖµµÄ³ÌÐò
 273   2            if(!PreChargeDACDuty)
 274   2              {
 275   3              //Èç¹ûÔ¤³äÍê³ÉÖ®ºó£¬ÒÑÓ¦ÓÃµÄµçÁ÷ºÍÄ¿±êÖµÍ¬²½ÔòÖ±½ÓÌø×ªµ½Õý³£Êä³ö×´Ì¬
 276   3              OutputFSMState=(CurrentBuf==TargetCurrent)?OutCH_OutputEnabled:OutCH_SubmitDuty;
 277   3              break;
 278   3              }
 279   2            //¿ªÊ¼Öð²½ÏÂµ÷Ô¤³äÕ¼¿Õ±È°ÑÊä³öµçÑ¹µ÷µ½¶î¶¨Öµ
 280   2            if(IsNeedToUploadPWM)break; //ÉÏ´Îµ÷Õû»¹Î´Íê±Ï
 281   2            ILIM=TargetCurrent/25;
 282   2            if(ILIM>200)ILIM=200; //¼ÆËã³öÃ¿´ÎPWMDACµÝ¼õµÄÖµ
 283   2            PreChargeDACDuty-=ILIM+1;
 284   2            if(PreChargeDACDuty<0)PreChargeDACDuty=0; //½ûÖ¹Õ¼¿Õ±ÈÎª¸ºÊý
 285   2            IsNeedToUploadPWM=1;
 286   2            break;
 287   2          //Ó¦ÓÃÕ¼¿Õ±È
 288   2          case OutCH_SubmitDuty:
 289   2            if(IsNeedToUploadPWM)break; //PWMÕýÔÚÓ¦ÓÃÖÐ£¬µÈ´ý
 290   2            if(TargetCurrent==0)OutputFSMState=OutCH_GracefulShut; //ÏµÍ³µçÁ÷ÅäÖÃÎª0£¬ËµÃ÷ÐèÒª½áÊøÔËÐÐ£¬Ìø×ªµ½´ý»ú
 291   2            //±£»¤LEDµÄµçÁ÷Ð±ÂÊÏÞÖÆÆ÷
 292   2            if(TargetCurrent-CurrentBuf>CalcIREFValue(6000))IsEnableSlowILEDRamp=1; //¼à²âµ½·Ç³£´óµÄµçÁ÷Ë²Ì¬£¬±ÜÃâ³
             -å±¬µÆÖé²ÉÓÃÈíÆð
 293   2            if(!SysMode&&IsEnableSlowILEDRamp)
 294   2              {
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 6   

 295   3              switch(CurrentMode->ModeIdx)
 296   3                {
 297   4                case Mode_Turbo:CurrentBuf+=IsInputLimited?0:10;break;  //¼«ÁÁMPPTÏµÍ³£¬ÅäºÏÊäÈë¸æ¾¯¼à²âÊ¹ÓÃ
 298   4                case Mode_Beacon:CurrentBuf+=5000;break;
 299   4                case Mode_Strobe:CurrentBuf+=1500;break;
 300   4                case Mode_SOS:CurrentBuf+=500;break;
 301   4                default:CurrentBuf+=15;
 302   4                }
 303   3              if(CurrentBuf>=TargetCurrent)
 304   3                {
 305   4                IsEnableSlowILEDRamp=0;
 306   4                CurrentBuf=TargetCurrent; //ÏÞ·ù£¬²»ÔÊÐíÄ¿±êµçÁ÷´óÓÚÔÊÐíÖµ
 307   4                }
 308   3              }
 309   2            else CurrentBuf=TargetCurrent; //Ö±½ÓÍ¬²½   
 310   2            //¸üÐÂÕ¼¿Õ±È
 311   2            IsNeedToUploadPWM=1;
 312   2            PWMDuty=Duty_Calc(CurrentBuf);
 313   2            //Õ¼¿Õ±ÈÒÑÍ¬²½£¬Ìø×ªµ½Õý³£ÔËÐÐ½×¶Î
 314   2            if(TargetCurrent==CurrentBuf)
 315   2              {
 316   3              IsCurrentRampUp=1; //±ê¼ÇµçÁ÷ÅÀÉý½áÊø
 317   3              OutputFSMState=OutCH_OutputEnabled;
 318   3              }
 319   2            break;
 320   2          //Êä³öÍ¨µÀÕý³£ÔËÐÐ½×¶Î
 321   2          case OutCH_OutputEnabled:
 322   2            if(!TargetCurrent)OutputFSMState=OutCH_GracefulShut;  //ÏµÍ³µçÁ÷ÅäÖÃÎª0£¬½øÈëÈí¹Ø»ú½×¶Î¿ªÊ¼ÏÂµ÷Êä³öµçÑ¹
 323   2            else if(TargetCurrent==-1)OutputFSMState=OutCH_EnterIdle; //ÏµÍ³µçÁ÷ÅäÖÃÎª-1£¬ËµÃ÷ÐèÒªÔÝÍ£LEDµçÁ÷£¬Ìø×ª
             -µ½ÔÝÍ£Á÷³Ì
 324   2            else if(TargetCurrent!=CurrentBuf)OutputFSMState=OutCH_SubmitDuty; //Õ¼¿Õ±È·¢Éú±ä¸ü£¬¿ªÊ¼½øÐÐ´¦Àí
 325   2            break;
 326   2          //Êä³öÍ¨µÀÈí¹Ø»ú¿ØÖÆ
 327   2          case OutCH_GracefulShut:
 328   2            //´ò¿ªLEDMOS²¢¹Ø±ÕDCDC
 329   2            LEDMOS=1;
 330   2            BOOSTRUN=0;
 331   2            //¸´Î»PWMDAC
 332   2            PWMDACEN=0;
 333   2            PreChargeDACDuty=2399;
 334   2            PWMDuty=0;
 335   2            IsNeedToUploadPWM=1;
 336   2            //Ìø×ªµ½µÈ´ýÊä³öµçÑ¹Ë¥¼õµÄ¹ý³Ì
 337   2            PreChargeFSMTimer=24; //µÈ´ýÊä³öµçÑ¹Ë¥¼õµÄ¹ý³Ì×î¶àµÈ´ý3Ãë
 338   2            OutputFSMState=OutCH_WaitVOUTDecay;
 339   2            break;
 340   2          //DCDC¹Ø±Õ£¬µÈ´ýÊä³öµçÑ¹Ë¥¼õ
 341   2          case OutCH_WaitVOUTDecay:
 342   2            //µÈ´ýÊä³öµçÑ¹Ë¥¼õ
 343   2            if(Data.OutputVoltage>15.6&&PreChargeFSMTimer)break;
 344   2            //¹Ø±ÕÔ¤³äPWMDAC
 345   2            PreChargeDACDuty=0;
 346   2            IsNeedToUploadPWM=1;
 347   2            //Êä³öµçÑ¹Ë¥¼õ½áÊø£¬¹Ø±ÕLEDMOSºÍ¸¨ÖúµçÔ´²¢»Øµ½´ý»ú×´Ì¬
 348   2            LEDMOS=0;
 349   2            AUXEN=0;
 350   2            PreChargeFSMTimer=0; //¸´Î»¼ÆÊ±Æ÷
 351   2            OutputFSMState=OutCH_Standby;
 352   2            break;
 353   2          //ÐèÒªÔÝÊ±¹Ø±ÕLED£¬ÔÚ½øÈëidleÖ®Ç°µÄ×¼±¸
 354   2          case OutCH_EnterIdle:
 355   2            //Á¢¼´ÈÃÔ¤³äPWMDAC°ÑµçÑ¹Ç¯×¡
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/17/2025 13:41:16 PAGE 7   

 356   2            PreChargeDACDuty=0x82A; //0x82A=87.128%=11.29-0.4815*14.4->(0.87128*5)
 357   2            IsNeedToUploadPWM=1;
 358   2            //µÈ´ýÊä³öµçÑ¹ÏÂ½µ
 359   2            if(CurrentMode->ModeIdx!=Mode_Beacon&&Data.OutputVoltage>17.3)break;
 360   2            LEDMOS=0; //¶Ï¿ªLEDMOSÇÐ¶ÏµçÁ÷
 361   2            OutputFSMState=OutCH_OutputIdle; //½øÈëidle×´Ì¬
 362   2            break;
 363   2          //ÔÝÊ±¹Ø±ÕLEDµÄµÈ´ý
 364   2          case OutCH_OutputIdle:
 365   2            if(TargetCurrent==0)OutputFSMState=OutCH_GracefulShut;  //ÏµÍ³µçÁ÷ÅäÖÃÎª0£¬½øÈëÈí¹Ø»ú½×¶Î
 366   2            if(TargetCurrent>0) //LEDµçÁ÷ÖØÐÂ´ò¿ª£¬ÐèÒªÆô¶¯Êä³ö
 367   2              {
 368   3              LEDMOS=1; //´ò¿ªLEDMOS£¬½ÓÍ¨µçÁ÷
 369   3              PreChargeDACDuty=0;
 370   3              IsNeedToUploadPWM=1; //ÁîPWMDAC¿ªÊ¼SysDown£¬LED·¢¹â
 371   3              OutputFSMState=OutCH_SubmitDuty; //Ó¦ÓÃ×îÐÂµÄÕ¼¿Õ±È
 372   3              }
 373   2            break;
 374   2          //¿¨³öÀ´µÄ·Ç·¨×´Ì¬»Øµ½Ä¬ÈÏ´ý»ú
 375   2          default:OutputFSMState=OutCH_PreChargeFailed;
 376   2          }
 377   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1468    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
