C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OUTPUTCHANNEL
OBJECT MODULE PLACED IN .\Objects\OutputChannel.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Hardware\OutputChannel.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODDP2 INCDIR(.\S
                    -tdDriver\inc;.\Hardware;.\include\Hardware;.\include\Logic;.\include\Middleware;.\include\System) DEFINE(EnableStdGPIO) 
                    -DEBUG PRINT(.\Listings\OutputChannel.lst) TABS(2) OBJECT(.\Objects\OutputChannel.obj)

line level    source

   1          #include "cms8s6990.h"
   2          #include "PinDefs.h"
   3          #include "GPIO.h"
   4          #include "PWMCfg.h"
   5          #include "delay.h"
   6          #include "SpecialMode.h"
   7          #include "TempControl.h"
   8          #include "OutputChannel.h"
   9          #include "ADCCfg.h"
  10          #include "SelfTest.h"
  11          
  12          //ÄÚ²¿SFR
  13          sbit AUXEN=AUXENIOP^AUXENIOx; //¸¨Öú6V DCDCÊ¹ÄÜ
  14          sbit PWMDACEN=PWMDACENIOP^PWMDACENIOx; //PWMDACÊ¹ÄÜ
  15          sbit SYSHBLED=SYSHBLEDIOP^SYSHBLEDIOx; //ÐÄÌøLED
  16          sbit BOOSTRUN=BOOSTRUNIOP^BOOSTRUNIOx; //LTC3787µÄEN
  17          sbit LEDMOS=LEDNegMOSIOP^LEDNegMOSIOx; //LEDMOSFET
  18          
  19          //Íâ²¿µçÁ÷ÅäÖÃ²Î¿¼
  20          xdata volatile int Current; //Ä¿±êµçÁ÷(mA)
  21          xdata int CurrentBuf; //´æ´¢µ±Ç°ÒÑ¾­ÉÏ´«µÄµçÁ÷Öµ 
  22          bit IsCurrentRampUp;  //µçÁ÷ÕýÔÚÉÏÉý¹ý³ÌÖÐµÄ±ê¼ÇÎ»£¨ÓÃÓÚºÍMPPTÊÔÌ½Áª¶¯£©
  23          
  24          //ÄÚ²¿±äÁ¿
  25          static bit IsEnableSlowILEDRamp; //±êÖ¾Î»£¬ÊÇ·ñÆôÓÃÂýËÙµçÁ÷Ð±ÂÊ¿ØÖÆ
  26          static xdata char PreChargeFSMTimer; //Ô¤³äµç×´Ì¬»ú¼ÆÊ±Æ÷
  27          static xdata OutChFSMStateDef OutputFSMState; //Êä³ö¿ØÖÆ×´Ì¬»ú
  28          static xdata char HBTimer; //ÐÄÌø¼ÆÊ±Æ÷
  29          
  30          /*********************************************************************************************************
             -************
  31          Êä³öÍ¨µÀ¿ØÖÆÆ÷ËùÊ¹ÓÃµÄÄÚ²¿º¯Êý£¬½öÄÜÔÚ¸ÃÎÄ¼þÄÚµ÷ÓÃ¡£
  32          **********************************************************************************************************
             -***********/
  33          
  34          //ÄÚ²¿ÓÃÓÚ¼ÆËãPWMDACÕ¼¿Õ±ÈµÄº¯Êý  
  35          static float Duty_Calc(int CurrentInput)
  36            {
  37   1        float buf;
  38   1        //¼ÆËãÊµ¼ÊÕ¼¿Õ±È
  39   1        buf=(float)CurrentInput*(float)MainChannelShuntmOhm; //ÊäÈë´«½øÀ´µÄµçÁ÷(mA)²¢³ËÒÔ¼ìÁ÷µç×è×èÖµ(mR)µÃµ½¼ìÁ÷
             -µç×è´¦µÄÄ¿±êµçÑ¹(uV)
  40   1        buf*=(float)0.0015; //uV×ªmV²¢¸ù¾Ý1.5mA per LSB»»ËãµÃµ½Êµ¼ÊµÄµçÁ÷Öµ
  41   1        buf*=CurrentSenseOpAmpGain; //½«¼ìÁ÷µç×è´¦µÄÄ¿±êµçÑ¹(mV)³ËÒÔ¼ìÁ÷·Å´óÆ÷µÄÔöÒæµÃµ½ÔË·Å¶ËµÄÕû¶¨Öµ
  42   1        buf/=Data.MCUVDD*(float)1000; //¼ÆËã³öÄ¿±êDACÊä³öµçÑ¹ºÍPWMDAC»º³åÆ÷¹©µçµçÑ¹(MCUVDD)Ö®¼äµÄ±ÈÖµ
  43   1        buf*=102; //×ª»»Îª°Ù·Ö±È(³ËÒÔ102²¹³¥µôÏµÍ³µÄ»»ËãÎó²î)
  44   1        //½á¹ûÊä³ö  
  45   1        return buf;
  46   1        }
  47            
  48          /*********************************************************************************************************
             -************
  49          Êä³öÍ¨µÀ¿ØÖÆÆ÷ËùÊ¹ÓÃµÄÍâ²¿º¯Êý£¬¿ÉÒÔÔÚÆäËûµØ·½µ÷ÓÃ¡£
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 2   

  50          **********************************************************************************************************
             -***********/
  51          
  52          //³õÊ¼»¯º¯Êý
  53          void OutputChannel_Init(void)
  54            {
  55   1        GPIOCfgDef OCInitCfg;
  56   1        //ÉèÖÃ½á¹¹Ìå
  57   1        OCInitCfg.Mode=GPIO_Out_PP;
  58   1        OCInitCfg.Slew=GPIO_Fast_Slew;    
  59   1        OCInitCfg.DRVCurrent=GPIO_High_Current; //ÍÆMOSFET,ÐèÒª¸ßÉÏÉýÐ±ÂÊ
  60   1        //µ÷ÓÃ¸´Î»º¯ÊýÖØÖÃËùÓÐ×´Ì¬
  61   1        OutputChannel_DeInit();
  62   1        //¿ªÊ¼ÅäÖÃIO  
  63   1        GPIO_ConfigGPIOMode(PWMDACENIOG,GPIOMask(PWMDACENIOx),&OCInitCfg);  
  64   1        GPIO_ConfigGPIOMode(AUXENIOG,GPIOMask(AUXENIOx),&OCInitCfg);      
  65   1        GPIO_ConfigGPIOMode(BOOSTRUNIOG,GPIOMask(BOOSTRUNIOx),&OCInitCfg);    
  66   1        GPIO_ConfigGPIOMode(LEDNegMOSIOG,GPIOMask(LEDNegMOSIOx),&OCInitCfg);
  67   1        GPIO_ConfigGPIOMode(SYSHBLEDIOG,GPIOMask(SYSHBLEDIOx),&OCInitCfg);    
  68   1        }
  69          
  70          //Ô¤³äµç×´Ì¬»ú¼ÆÊ±Æ÷
  71          void OCFSM_TIMHandler(void)
  72            {
  73   1        //ÐÄÌøLED¿ØÖÆ 
  74   1        if(CurrentMode->ModeIdx==Mode_Fault) //·¢Éú¹ÊÕÏÊ±HB¿ìÉÁ
  75   1          SYSHBLED=SYSHBLED?0:1; //·­×ªLED
  76   1        else if(GetIfOutputEnabled())SYSHBLED=1;//Êä³öÒÑÆôÓÃ£¬LEDÅäÖÃÎª1    
  77   1        else //´ý»ú×´Ì¬ÏÂÂýÉÁ
  78   1          {
  79   2          if(HBTimer<4)HBTimer++;
  80   2          else
  81   2            {
  82   3            SYSHBLED=SYSHBLED?0:1; //·­×ªLED
  83   3            HBTimer=0;
  84   3            }
  85   2          }
  86   1        //×´Ì¬»ú¼ÆÊ±Æ÷
  87   1        if(PreChargeFSMTimer>0)PreChargeFSMTimer--;
  88   1        } 
  89            
  90          //Êä³öÍ¨µÀ¸´Î»
  91          void OutputChannel_DeInit(void)
  92            {
  93   1        BOOSTRUN=0;
  94   1        AUXEN=0;
  95   1        LEDMOS=0;
  96   1        PWMDACEN=0;
  97   1        SYSHBLED=0; //ËùÓÐbit¶¼Îª0
  98   1        //ÏµÍ³ÉÏµçÊ±µçÁ÷ÅäÖÃÎª0
  99   1        Current=0;
 100   1        CurrentBuf=0;
 101   1        IsCurrentRampUp=0;
 102   1        IsEnableSlowILEDRamp=0;
 103   1        //¸´Î»×´Ì¬»ú
 104   1        HBTimer=0;
 105   1        OutputFSMState=OutCH_Standby;
 106   1        } 
 107          
 108          //Íâ²¿»ñÈ¡Êä³öÊÇ·ñÕý³£ÆôÓÃµÄº¯Êý
 109          bit GetIfOutputEnabled(void)  
 110            {
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 3   

 111   1        if(OutputFSMState==OutCH_OutputEnabled)return 1;
 112   1        if(OutputFSMState==OutCH_SubmitDuty)return 1;
 113   1        //·ñÔò·µ»Ø0
 114   1        return 0;
 115   1        }
 116          
 117          //»ñÈ¡ÏµÍ³ÊÇ·ñÔÚ°²È«¹Ø»ú½×¶Î
 118          bit GetIfSystemInPOFFSeq(void)
 119            {
 120   1        //Èç¹ûÏµÍ³´¦ÔÚÈí¹Ø»úµÄµÈ´ý½×¶ÎÔò²»ÔÊÐí¹Ø±Õ  
 121   1        if(OutputFSMState==OutCH_WaitVOUTDecay)return 1;
 122   1        if(OutputFSMState==OutCH_GracefulShut)return 1;   
 123   1        //ÏµÍ³ÒÑ¾­¹Ø±Õ£¬·µ»Ø0
 124   1        return 0;
 125   1        } 
 126            
 127          //Êä³öÍ¨µÀÊÔÔËÐÐ
 128          void OutputChannel_TestRun(void)
 129            {
 130   1        char retry=100;
 131   1        bit IsDCDCOV=0;
 132   1        //´ò¿ª¸¨ÖúµçÔ´ºÍPWMDAC
 133   1        AUXEN=1;
 134   1        PWMDACEN=1;
 135   1        PWM_ForceEnableOut(1);
 136   1        //ÑÓÊ±40mSºó¼ì²âµçÑ¹£¬Èç¹ûµçÑ¹´óÓÚ8VÔòÕý³£Æô¶¯½øÐÐ¼ì²â
 137   1        delay_ms(40);
 138   1        SystemTelemHandler();
 139   1        if(Data.RawBattVolt>8)BOOSTRUN=1; //Áî3787EN=1£¬Æô¶¯Êä³ö
 140   1        else 
 141   1          {
 142   2          PWM_ForceEnableOut(0);
 143   2          OutputChannel_DeInit(); //¹Ø±ÕPWMÊä³ö²¢¸´Î»Êä³öÍ¨µÀ
 144   2          return;
 145   2          }
 146   1        //¼ì²éÊä³ö×´Ì¬
 147   1        do
 148   1          {
 149   2          SystemTelemHandler();
 150   2          if(Data.OutputVoltage>16.5)IsDCDCOV=1; //±ê¼Ç³öÏÖ¹ýÑ¹
 151   2          else if(Data.OutputVoltage>14.0)
 152   2            {
 153   3            //¼ì²éÍ¨¹ý£¬¹Ø±ÕDCDC
 154   3            BOOSTRUN=0;
 155   3            delay_ms(5);
 156   3            //¸´Î»PWMDAC
 157   3            PWMDACEN=0;
 158   3            PWM_ForceEnableOut(0);
 159   3            //¹Ø±Õ¸¨ÖúµçÔ´
 160   3            AUXEN=0;  
 161   3            return;
 162   3            }
 163   2          //¼ì²éÊ§°Ü
 164   2          delay_ms(5);
 165   2          retry--;
 166   2          }
 167   1        while(retry>0);
 168   1        //DCDC¼ì²é³¬Ê±£¬±¨¸æ´íÎó
 169   1        ReportError(IsDCDCOV?Fault_DCDCPreChargeFailed:Fault_DCDCFailedToStart);
 170   1        }
 171          
 172          //Êä³öÍ¨µÀ¼ÆËã
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 4   

 173          void OutputChannel_Calc(void)
 174            {
 175   1        int TargetCurrent,ILIM;
 176   1        extern bit IsBatteryAlert;
 177   1        //¶ÁÈ¡Ä¿±êµçÁ÷
 178   1        TargetCurrent=Current;
 179   1        if(Current>0) //µçÁ÷´óÓÚ0ËµÃ÷ÊÇÓÐÐ§Êä³öÖ´ÐÐÎÂ¿Ø¼ÆËã
 180   1          {
 181   2          //ÎÂ¿Ø¼ÆËã
 182   2          ILIM=ThermalILIMCalc();
 183   2          if(TargetCurrent>ILIM)TargetCurrent=ILIM; //ÎÂ¿Ø·´À¡µÄÔËÐÐµçÁ÷³¬¹ýÄ¿±êÖµ£¬½øÐÐÏÞÁ÷
 184   2          }
 185   1        //½øÐÐÊä³öÍ¨µÀ×´Ì¬»ú¹ÜÀí
 186   1        switch(OutputFSMState)
 187   1          {
 188   2          //Êä³öÍ¨µÀ¹ÊÕÏ  
 189   2          case OutCH_PreChargeFailed:
 190   2             OutputChannel_DeInit(); //Ö´ÐÐÊä³ö¸´Î»
 191   2             break; 
 192   2          //Êä³öÍ¨µÀ´ý»ú×´Ì¬
 193   2          case OutCH_Standby:
 194   2             //¸´Î»DCDC¿ØÖÆ
 195   2             BOOSTRUN=0;
 196   2             AUXEN=0;
 197   2             LEDMOS=0;
 198   2             PWMDACEN=0;
 199   2             //¸´Î»±ê¼ÇÎ»
 200   2             IsCurrentRampUp=0;
 201   2             //¸´Î»PWMDAC
 202   2             if(PreChargeDACDuty||PWMDuty>0)
 203   2              {
 204   3              PreChargeDACDuty=0;
 205   3              PWMDuty=0;
 206   3              IsNeedToUploadPWM=1;
 207   3              }
 208   2             //Èç¹ûµçÁ÷·¢Éú±ä¸üÔò½øÈëÆô¶¯×´Ì¬
 209   2             if(TargetCurrent>0)OutputFSMState=OutCH_PWMDACPreCharge;
 210   2             break;
 211   2          //Æô¶¯²½Öè1£¬ËÍ³öPWMDAC
 212   2          case OutCH_PWMDACPreCharge:
 213   2             //Æô¶¯µçÁ÷Õû¶¨DAC
 214   2             PWMDACEN=1;
 215   2             //ÅäÖÃPWMDACÕ¼¿Õ±È
 216   2             CurrentBuf=TargetCurrent>CalcIREFValue(1500)?CalcIREFValue(1500):TargetCurrent;
 217   2             PWMDuty=Duty_Calc(CurrentBuf);  //ÅäÖÃÁ÷³ÌÊÇÈç¹ûµ±Ç°µçÁ÷´óÓÚ1.5A£¬ÔòÇ¯Î»µ½1.5A£¬È»ºóÓÃÕâ¸ö³õÖµÅäÖÃPWMD
             -AC
 218   2             //Æô¶¯CVÏÞÑ¹»·DAC
 219   2             PreChargeDACDuty=0x82A; //0x82A=87.128%=11.29-0.4815*14.4->(0.87128*5)
 220   2             //ÉÏ´«Õ¼¿Õ±È²¢Ìø×ªµ½ÏÂÒ»²½(Æô¶¯Ö÷DCDC¸¨ÖúPSU)
 221   2             IsNeedToUploadPWM=1;
 222   2             OutputFSMState=OutCH_StartAUXPSU;
 223   2             break;
 224   2          //Æô¶¯²½Öè2£¬Æô¶¯¸¨ÖúPSU£¨¸øLTC3787¹©µçµÄµçÔ´£©
 225   2          case OutCH_StartAUXPSU:
 226   2             //µÈ´ýPWMÊä³ö
 227   2             if(IsNeedToUploadPWM)break;
 228   2             delay_ms(20); //ÑÓÊ±20mS
 229   2             //Æô¶¯¸¨ÖúµçÔ´²¢Ìø×ªµ½ÏÂ¸ö×´Ì¬
 230   2             AUXEN=1;
 231   2             PreChargeFSMTimer=16; //ÉèÖÃ¼ÆÊ±Æ÷×î¶àµÈ´ý2Ãë
 232   2             OutputFSMState=OutCH_EnableBoost;
 233   2             break;
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 5   

 234   2          //Æô¶¯²½Öè3£¬Æô¶¯Ö÷DCDC²¢¼ì²éÊä³öÊÇ·ñÕý³£
 235   2          case OutCH_EnableBoost:
 236   2            //Áî3787EN=1£¬Ö÷Boost¿ªÊ¼Êä³öÈ»ºó¼ì²âµçÑ¹×´Ì¬
 237   2            BOOSTRUN=1;
 238   2            if(Data.OutputVoltage>14.0)OutputFSMState=OutCH_ReleasePreCharge; //µçÑ¹ÆðÀ´ÁË£¬¼ÌÐøÆô¶¯Á÷³Ì
 239   2            //µÈ´ý³¬Ê±ºó±¨´í
 240   2            if(PreChargeFSMTimer>0)break;
 241   2            ReportError(Fault_DCDCFailedToStart);
 242   2            OutputFSMState=OutCH_PreChargeFailed;
 243   2            break;
 244   2          //Æô¶¯²½Öè4£¬Öð²½ÏÂµ÷Ô¤³äPWMDACÌ§ÉýÊä³öµçÑ¹
 245   2          case OutCH_ReleasePreCharge:
 246   2            //½ÓÍ¨LED¸º¼«FET£¬LED¿ªÊ¼·¢¹â
 247   2            LEDMOS=1;
 248   2            //Èç¹ûµçÁ÷Îª0Ôò¿ªÊ¼½øÈë·Åµç½×¶Î
 249   2            if(TargetCurrent==0)OutputFSMState=OutCH_GracefulShut;
 250   2            //Èç¹ûÕ¼¿Õ±Èµ÷Õûµ½0ÁËÔò½øÈëÌáÉýÊä³öµçÁ÷µ½Ä¿±êÖµµÄ³ÌÐò
 251   2            if(!PreChargeDACDuty)
 252   2              {
 253   3              //Èç¹ûÔ¤³äÍê³ÉÖ®ºó£¬ÒÑÓ¦ÓÃµÄµçÁ÷ºÍÄ¿±êÖµÍ¬²½ÔòÖ±½ÓÌø×ªµ½Õý³£Êä³ö×´Ì¬
 254   3              OutputFSMState=(CurrentBuf==TargetCurrent)?OutCH_OutputEnabled:OutCH_SubmitDuty;
 255   3              break;
 256   3              }
 257   2            //¿ªÊ¼Öð²½ÏÂµ÷Ô¤³äÕ¼¿Õ±È°ÑÊä³öµçÑ¹µ÷µ½¶î¶¨Öµ
 258   2            if(IsNeedToUploadPWM)break; //ÉÏ´Îµ÷Õû»¹Î´Íê±Ï
 259   2            ILIM=TargetCurrent/25;
 260   2            if(ILIM>200)ILIM=200; //¼ÆËã³öÃ¿´ÎPWMDACµÝ¼õµÄÖµ
 261   2            PreChargeDACDuty-=ILIM+1;
 262   2            if(PreChargeDACDuty<0)PreChargeDACDuty=0; //½ûÖ¹Õ¼¿Õ±ÈÎª¸ºÊý
 263   2            IsNeedToUploadPWM=1;
 264   2            break;
 265   2          //Ó¦ÓÃÕ¼¿Õ±È
 266   2          case OutCH_SubmitDuty:
 267   2            if(IsNeedToUploadPWM)break; //PWMÕýÔÚÓ¦ÓÃÖÐ£¬µÈ´ý
 268   2            if(TargetCurrent==0)OutputFSMState=OutCH_GracefulShut; //ÏµÍ³µçÁ÷ÅäÖÃÎª0£¬ËµÃ÷ÐèÒª½áÊøÔËÐÐ£¬Ìø×ªµ½´ý»ú
 269   2            //±£»¤LEDµÄµçÁ÷Ð±ÂÊÏÞÖÆÆ÷
 270   2            if(TargetCurrent-CurrentBuf>CalcIREFValue(6000))IsEnableSlowILEDRamp=1; //¼à²âµ½·Ç³£´óµÄµçÁ÷Ë²Ì¬£¬±ÜÃâ³
             -å±¬µÆÖé²ÉÓÃÈíÆð
 271   2            if(!SysMode&&IsEnableSlowILEDRamp)
 272   2              {
 273   3              switch(CurrentMode->ModeIdx)
 274   3                {
 275   4                case Mode_Turbo:CurrentBuf+=IsInputLimited?0:10;break;  //¼«ÁÁMPPTÏµÍ³£¬ÅäºÏÊäÈë¸æ¾¯¼à²âÊ¹ÓÃ
 276   4                case Mode_Beacon:CurrentBuf+=5000;break;
 277   4                case Mode_Strobe:CurrentBuf+=1500;break;
 278   4                case Mode_SOS:CurrentBuf+=500;break;
 279   4                default:CurrentBuf+=15;
 280   4                }
 281   3              if(CurrentBuf>=TargetCurrent)
 282   3                {
 283   4                IsEnableSlowILEDRamp=0;
 284   4                CurrentBuf=TargetCurrent; //ÏÞ·ù£¬²»ÔÊÐíÄ¿±êµçÁ÷´óÓÚÔÊÐíÖµ
 285   4                }
 286   3              }
 287   2            else CurrentBuf=TargetCurrent; //Ö±½ÓÍ¬²½   
 288   2            //¸üÐÂÕ¼¿Õ±È
 289   2            IsNeedToUploadPWM=1;
 290   2            PWMDuty=Duty_Calc(CurrentBuf);
 291   2            //Õ¼¿Õ±ÈÒÑÍ¬²½£¬Ìø×ªµ½Õý³£ÔËÐÐ½×¶Î
 292   2            if(TargetCurrent==CurrentBuf)
 293   2              {
 294   3              IsCurrentRampUp=1; //±ê¼ÇµçÁ÷ÅÀÉý½áÊø
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 6   

 295   3              OutputFSMState=OutCH_OutputEnabled;
 296   3              }
 297   2            break;
 298   2          //Êä³öÍ¨µÀÕý³£ÔËÐÐ½×¶Î
 299   2          case OutCH_OutputEnabled:
 300   2            if(!TargetCurrent)OutputFSMState=OutCH_GracefulShut;  //ÏµÍ³µçÁ÷ÅäÖÃÎª0£¬½øÈëÈí¹Ø»ú½×¶Î¿ªÊ¼ÏÂµ÷Êä³öµçÑ¹
 301   2            else if(TargetCurrent==-1)OutputFSMState=OutCH_EnterIdle; //ÏµÍ³µçÁ÷ÅäÖÃÎª-1£¬ËµÃ÷ÐèÒªÔÝÍ£LEDµçÁ÷£¬Ìø×ª
             -µ½ÔÝÍ£Á÷³Ì
 302   2            else if(TargetCurrent!=CurrentBuf)OutputFSMState=OutCH_SubmitDuty; //Õ¼¿Õ±È·¢Éú±ä¸ü£¬¿ªÊ¼½øÐÐ´¦Àí
 303   2            break;
 304   2          //Êä³öÍ¨µÀÈí¹Ø»ú¿ØÖÆ
 305   2          case OutCH_GracefulShut:
 306   2            //´ò¿ªLEDMOS²¢¹Ø±ÕDCDC
 307   2            LEDMOS=1;
 308   2            BOOSTRUN=0;
 309   2            //¸´Î»PWMDAC
 310   2            PWMDACEN=0;
 311   2            PreChargeDACDuty=2399;
 312   2            PWMDuty=0;
 313   2            IsNeedToUploadPWM=1;
 314   2            //Ìø×ªµ½µÈ´ýÊä³öµçÑ¹Ë¥¼õµÄ¹ý³Ì
 315   2            PreChargeFSMTimer=24; //µÈ´ýÊä³öµçÑ¹Ë¥¼õµÄ¹ý³Ì×î¶àµÈ´ý3Ãë
 316   2            OutputFSMState=OutCH_WaitVOUTDecay;
 317   2            break;
 318   2          //DCDC¹Ø±Õ£¬µÈ´ýÊä³öµçÑ¹Ë¥¼õ
 319   2          case OutCH_WaitVOUTDecay:
 320   2            //µÈ´ýÊä³öµçÑ¹Ë¥¼õ
 321   2            if(Data.OutputVoltage>15.6&&PreChargeFSMTimer)break;
 322   2            //¹Ø±ÕÔ¤³äPWMDAC
 323   2            PreChargeDACDuty=0;
 324   2            IsNeedToUploadPWM=1;
 325   2            //Êä³öµçÑ¹Ë¥¼õ½áÊø£¬¹Ø±ÕLEDMOSºÍ¸¨ÖúµçÔ´²¢»Øµ½´ý»ú×´Ì¬
 326   2            LEDMOS=0;
 327   2            AUXEN=0;
 328   2            PreChargeFSMTimer=0; //¸´Î»¼ÆÊ±Æ÷
 329   2            OutputFSMState=OutCH_Standby;
 330   2            break;
 331   2          //ÐèÒªÔÝÊ±¹Ø±ÕLED£¬ÔÚ½øÈëidleÖ®Ç°µÄ×¼±¸
 332   2          case OutCH_EnterIdle:
 333   2            //Á¢¼´ÈÃÔ¤³äPWMDAC°ÑµçÑ¹Ç¯×¡
 334   2            PreChargeDACDuty=0x82A; //0x82A=87.128%=11.29-0.4815*14.4->(0.87128*5)
 335   2            IsNeedToUploadPWM=1;
 336   2            //µÈ´ýÊä³öµçÑ¹ÏÂ½µ
 337   2            if(CurrentMode->ModeIdx!=Mode_Beacon&&Data.OutputVoltage>17.3)break;
 338   2            LEDMOS=0; //¶Ï¿ªLEDMOSÇÐ¶ÏµçÁ÷
 339   2            OutputFSMState=OutCH_OutputIdle; //½øÈëidle×´Ì¬
 340   2            break;
 341   2          //ÔÝÊ±¹Ø±ÕLEDµÄµÈ´ý
 342   2          case OutCH_OutputIdle:
 343   2            if(TargetCurrent==0)OutputFSMState=OutCH_GracefulShut;  //ÏµÍ³µçÁ÷ÅäÖÃÎª0£¬½øÈëÈí¹Ø»ú½×¶Î
 344   2            if(TargetCurrent>0) //LEDµçÁ÷ÖØÐÂ´ò¿ª£¬ÐèÒªÆô¶¯Êä³ö
 345   2              {
 346   3              LEDMOS=1; //´ò¿ªLEDMOS£¬½ÓÍ¨µçÁ÷
 347   3              PreChargeDACDuty=0;
 348   3              IsNeedToUploadPWM=1; //ÁîPWMDAC¿ªÊ¼SysDown£¬LED·¢¹â
 349   3              OutputFSMState=OutCH_SubmitDuty; //Ó¦ÓÃ×îÐÂµÄÕ¼¿Õ±È
 350   3              }
 351   2            break;
 352   2          //¿¨³öÀ´µÄ·Ç·¨×´Ì¬»Øµ½Ä¬ÈÏ´ý»ú
 353   2          default:OutputFSMState=OutCH_PreChargeFailed;
 354   2          }
 355   1        }
C51 COMPILER V9.60.0.0   OUTPUTCHANNEL                                                     05/18/2025 17:01:21 PAGE 7   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1383    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
